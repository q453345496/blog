#ArrayList
1.ensureCapacityInternal内部确保容量大小,new时不指定大小,则第一次扩容为10
2.ensureExplicitCapacity显式确保容量大小,真正执行扩容的方法,当所需容量大于当前长度时进行扩容,一般是1.5,如果还小就直接取容量值
3.无参数DEFAULTCAPACITY_EMPTY_ELEMENTDATA,在第一次添加时使用默认容量10,有参数EMPTY_ELEMENTDATA
4.因为无参数初始化时都指向同一个{},所以节省了很多内存
5.Fail-Fast机制,快速失败机制
6.removeIf使用BitSet记录位置

#HashMap
取余(%)操作中如果除数是2的幂次方，则等同于与其除数减一的与(&)操作
(h = key.hashCode()) ^ (h >>> 16)仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。
1.resize都是2的幂,这样n-1确保每一位都是1,如果为0就可能产生更多碰撞而且浪费空间,所以hash每一位都参与了运算,(n-1)&hash为索引,产生包正在0~n-1范围内
2.链表大于8的变成红黑树,反之,小于6的变为链表。注意，如果数组的大小小于64时,如果变成树,是会被认为数组长度不够导致冲突太多,所以不会变成树而是进行扩容
3.扩容后高位和地位的概率为50%,因为hash&(new-1)和hash&old,因为new是old的2倍,所以其索引没变或者为索引+old,可以进行计算得出一样的结果
比如hash=5,old=8时,5^(8-1)=5,5^(8)=0,5^(16-1)=5
0101
0111
0101=5

0101
1000
0000=0  ==0 为0则索引不变,为1则旧索引+old,也就是只需要计算新的高位来决定,这就是2的次数的好处

0101
1111
0101=5

hash=13,old=8时,13^(8-1)=5,13^(8)=8!=0,13^(16-1)=5
1101
0111
0101=5

1101
1000
1000=8!=0 不为0则索引为旧索引+old,即13

1101
1111
1101=13

省去了重新计算hash的时间；
由于e.hash & oldCap的结果可以理解为随机的，要么1要么0，这是由高一位决定的，所以这样就均匀的把有冲突的节点分散开来了；

扩容后,新数组中的链表顺序依然与旧数组中的链表顺序保持一致。
4.不管是链表还是树都是折半查找
5.红黑树,左旋转、右旋转、变色
6.tableSizeFor,算法主要是使所有位数变为1,并找到大于等于2的幂
因为n不为0,则考虑最高位的1,右移一位并进行或运算后,其相邻一位也是1,也就是第二位也变成1,在这基础上继续右移动2位,运算后就会把后续的第三和第四位变成1,最终全变成1
为什么要对cap做减1操作。
int n = cap - 1; 
这是为了防止，cap已经是2的幂。如果cap已经是2的幂， 又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。


事务具有4个特性：Atomicity（原子性），Consistency（一致性），Isolation（隔离性），Durability（持久性）